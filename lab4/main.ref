*$FROM LibraryEx
$EXTERN Map, Reduce;
*$FROM List
$EXTERN List-Create, List-Insert, List-InitForEach,
List-Append, List-AppendList, List-Get, List-ToJSON, List-Keys, List-WhereIn;
$ENTRY GO {
    , <Open 'r' 1 <Arg 1>> :
    , <Get 1> : '#for'
    , <Get 1> : e.Type
    , e.Type : {
        'i'
        , <Get 1> : e.pofik
        , <ParseAutomata 1> : t.Automata
        , <ParseFollow 1> : t.Follow
        , <Close 1> :
        , <Open 'w' 1 <Arg 2>> :
        = <Putout 1 <SLRCheck t.Automata t.Follow>><Close 1>;
        'p'
        , <Get 1> : e.pofik
        , <ReadLines 1 ('#state')> : e.Priority'\n#arrow\n'e.Arrow'\n#line\n'e.Line'\n#counter\n'
            e.Counter'\n#string\n'e.String
*        , <Prout given e.Counter> :
        , e.Priority : {
            'false' = <Br '<=>'><Br '>=<'>;
            'true' = <Br '<=<'><Br '>=>'>;
        } :
        , <ParseSTerms 1> : t.Terms
*        , <Prout <List-ToJSON t.Terms>> :
        , <ParsePaths 1> : t.Paths
*        , <Prout <List-ToJSON t.Paths>> :
        , <ParseFollow 1> : t.Follow
*        , <Prout <List-ToJSON t.Follow>> :
        , <Br 'Paths='t.Paths> :
*        , <Prout SORTED <Sort <List-Keys t.Terms>>> :
        , <Br 'OrdTerms='<Sort <List-Keys t.Terms>>> :
        , <Lenw e.String> : s.SL e.String
        , <Br 'StrLen='s.SL> :
*        , <Prout e.String'shift by 'e.Arrow> :
        , <Shift (1) (<Numb e.Line>) (<Numb 0>) (<Numb e.Arrow>) (<Numb 0>) e.String>
        : (e.Line^) (e.Counter^) e.String^
*        , <Prout 'is 'e.String' line is 'e.Line> :
*        , <Exit 0> :
        , <PanicRead t.Follow t.Terms (<Numb e.Arrow>) (e.Line) (e.Counter) e.String> :
        = ;
    };
}

Shift {
    (e.Line) (e.LineIgnore) (e.Counter) (e.Arrow) (e.Arrow) e.String
    = (e.Line) (e.Counter) e.String;
    (e.Line) (e.Line) (e.Counter) (e.Arrow) (e.Cur) s.C e.String
*    , <Prout e.Line (e.Cur' 'e.Arrow)> :
    , s.C : {
        '\n' = <Shift (<Add (e.Line) 1>) (e.Line) (<Add (e.Cur) 1>) (e.Arrow) (<Add (e.Cur) 1>) e.String>;
        s.C = <Shift (e.Line) (e.Line) (e.Counter) (e.Arrow) (<Add (e.Cur) 1>) e.String>;
    };
    (e.Line) (e.LineIgnore) (e.Counter) (e.Arrow) (e.Cur) s.C e.String
    , s.C : {
        '\n' = <Shift (<Add (e.Line) 1>) (e.LineIgnore) (<Add (e.Cur) 1>) (e.Arrow) (<Add (e.Cur) 1>) e.String>;
        s.C = <Shift (e.Line) (e.LineIgnore) (e.Counter) (e.Arrow) (<Add (e.Cur) 1>) e.String>;
    };
}

PanicRead {
    t.Follow t.Terms (e.Arrow) (e.Line) (e.Counter) /*empty*/
    = <Prout 'Is it possible?'><Exit 1>;
    t.Follow t.Terms (e.Arrow) (e.Line) (e.Counter) 'Δ\n'
    , <Prout delta> :
    = <WriteResults (e.Arrow) (e.Line) (e.Counter) (0) 0>;
    t.Follow t.Terms (e.Arrow) (e.Line) (e.Counter) '\n' e.String
*    , <Prout NEWLINE > :
    = <PanicRead t.Follow t.Terms
        (<Add (e.Arrow) 1>) (<Add (e.Line) 1>)
        (e.Arrow) e.String>;

    t.Follow t.Terms (e.Arrow) (e.Line) (e.Counter) s.C e.String
    , <IsFollow t.Follow t.Terms s.C> : {
        (e.Len) e.T = <WriteResults (<Add (e.Arrow) 1>) (e.Line) (e.Counter) (e.T) e.Len>;
        /*empty*/ = <PanicRead t.Follow t.Terms (<Add (e.Arrow) 1>) (e.Line) (e.Counter) e.String>;
    };

    t.Follow t.Terms e.Else = <Prout ERR e.Else> <Exit 0 >;

}

WriteResults {
    (e.Arrow) (e.Line) (e.Counter) (e.T) e.Len
    , <Open 'w' 2 <Arg 2>> :
    , <Prout (e.Arrow) (e.Line) (e.Counter) (e.T) e.Len> :
    = <Putout 2 '#arrow\n'e.Arrow'\n#line\n'e.Line'\n#counter\n'e.Counter
        '\n#nterm\n'e.T'\n#drop\n'<Symb e.Len>><Close 2>;
}

HighestTerms_ {
    (e.TB(e.T)e.TE) (e.T) e.Terms
    = e.T;
    (e.TB(e.T)e.TE) (e.T2) e.Terms
    = <HighestTerms_ (e.TB(e.T)e.TE) e.Terms>;
    (e.TB(e.T)e.TE) /*empty*/
    = <Prout ERR> <Exit 1>;
}

HighestTerm {
    e.T
    , <Cp 'OrdTerms'> : e.OTerms
*    , <Prout RUN (e.T)' 'e.OTerms' : '<HighestTerms_ (e.T) e.OTerms>> :
    = <HighestTerms_ (e.T) e.OTerms>;
}

HighestRule {
    (e.Max) (e.a'.'e.b) e.Rules
    , <Lenw e.a> : s.L e.a
    , <Compare (e.Max) s.L> : {
        '+' = <HighestRule (e.Max) e.Rules>;
        e.le = <HighestRule (s.L) e.Rules>;
    };
    (e.Max) = e.Max;
}

Filter {
    (e.LB(e.I)e.LE) e.KB (e.I) e.KE
    = (e.I)<Filter (e.LB e.LE) e.KB e.KE>;
    (e.L) e.V
    = ;
}

IsFollow {
    t.Follow t.Terms e.C
    , <List-WhereIn t.Follow e.C> : {
        /*empty*/
*        , <Prout NOTHING (e.C) IN t.Follow> :
        = ;
        e.Terms1
*        , <Prout (e.Terms1) <List-Keys t.Terms>> :
*        , <Filter (e.Terms1) <List-Keys t.Terms>> : e.Terms1^
*        , <Prout (e.Terms1)> :
*        , <Prout FOUND e.C IN e.Terms> :
        , <HighestTerm e.Terms1> : e.Term
        , <List-Get t.Terms e.Term> : e.Rules
        = (<HighestRule (0) e.Rules>) e.Term;
    }
}

ParseSTerms {
    s.Stream
    , <List-Create> : t.States
    = <ParseSTerms_ s.Stream t.States>;
}

ParseSTerms_ {
    s.Stream t.States
    , <Get s.Stream> : {
        e.Term' ➡ 'e.Rule = <ParseSTerms_ s.Stream <List-Append t.States (e.Term) e.Rule>>;
        '#paths' = t.States;
    }
}

ParsePaths_ {
    s.Stream t.Paths (e.N)
    , <Get s.Stream> : {
        '#begin' = <ParsePaths_ s.Stream t.Paths (e.N)>;
        '#end' = <ParsePaths_ s.Stream t.Paths (<Add (e.N) 1>)>;
        '#follow' = t.Paths;
        e.Term = <ParsePaths_ s.Stream <List-Append t.Paths (e.N) e.Term> (e.N)>;
    };
}

ParsePaths {
    s.Stream
    , <List-Create> : t.Paths
    = <ParsePaths_ s.Stream t.Paths (0)>;
}

ParseState {
    (e.N) s.Stream t.List
    , <Get s.Stream> : {
        '#end' = t.List;
        e.Rule = <ParseState (e.N) s.Stream <List-Append t.List (e.N) e.Rule>>;
    };
}

ParseAutomata_ {
    s.Stream t.List
    , <Get s.Stream> :  {
        '#State = 'e.N
        , <Get s.Stream> : e.Begin
        = <ParseAutomata_ s.Stream <ParseState (e.N) s.Stream t.List>>;
        '#follow' = t.List;
    };
}

ParseAutomata {
    s.Stream
    , <List-Create> : t.List
    = <ParseAutomata_ s.Stream t.List>;
}

ParseFTerm {
    s.Stream t.List (e.T)
    , <Get s.Stream> : {
        '#end' = t.List;
        e.F = <ParseFTerm s.Stream <List-Append t.List (e.T) e.F> (e.T)>;
    };
}

ParseFollow_ {
    s.Stream t.List
    , <Get s.Stream> : {
        '#Nterm = 'e.T
        , <Get s.Stream> : e.Begin
        , <ParseFTerm s.Stream t.List (e.T)> : t.List^
        = <ParseFollow_ s.Stream t.List>;
        0 = t.List;
        e.Else = <Prout e.Else><Exit 0>;
    };
}

ParseFollow {
    s.Stream
    , <List-Create> : t.List
    = <ParseFollow_ s.Stream t.List>;
}

IsIn {
    (e.LB (e.X) e.LE) e.X = True;
    e.Else = False
}

FindSRConflict {
    t.Follow (s.a) (s.X) e.VB (e.T1' ➡ 'e.a s.a'.') e.VE
*    , <Prout MAYBE FOR (s.a) (X s.X)> :
    , <List-Get t.Follow e.T1> : e.F
*    , <Prout FOLLOW FOR (e.T1) IS e.F> :
    , <IsIn (e.F) s.X> : {
        True = True;
        False = <FindSRConflict t.Follow (s.a) (s.X) e.VE>;
    };
    t.Automata (s.a) (s.X) e.V
    = False;
*    = <Prout NOT FOUND FOR (s.a) (s.X) IN e.V>False;
}

ShiftReduceState {
    t.Follow e.VB (e.T1' ➡ 'e.a s.a'.'s.X e.b) e.VE
*    , <Prout (e.T1' ➡ 'e.a s.a'.'s.X e.b) (s.X) (e.b)> :
    , <IsNTerm s.X> : {
        True = <ShiftReduceState t.Follow e.VE>;
        False
*        , <Prout RUN FOR s.X> :
        , <FindSRConflict t.Follow (s.a) (s.X) e.VB e.VE> : {
            True = True;
            False = <ShiftReduceState t.Follow e.VE>;
        };
    };
    t.Follow e.Else
    = False;
*    = <Prout NOT FOUND (e.Else)>False;
}

ShiftReduce {
    t.Automata t.Follow e.N
    , <List-Get t.Automata <Symb e.N>> : {
        /*empty*/ = False;
        e.V
*        , <Prout (e.N) (e.V)> :
        , <ShiftReduceState t.Follow e.V> : {
            True = True;
            False = <ShiftReduce t.Automata t.Follow <Add (e.N) 1>>;
        };
    };
}

IsNTerm {
    s.A
    , <Compare (<Ord s.A>) <Ord 'Z'>> : {
        '-'
        , <Compare (<Ord s.A>) <Ord 'A'>> : {
            '-' = False;
            s.E = True;
        };
        s.E = False;
    };
    e.T = True; /*eps?*/
}

Intersection {
    (e.TB(e.T)e.TE) e.TBB e.T e.TEE
    = True;
    (e.T1) e.T2
    = False;
}

FindRRConflict {
    t.Follow (e.A) e.VB (e.B' ➡ 'e.bb'.') e.VE
    , <List-Get t.Follow e.A> : e.AF
    , <List-Get t.Follow e.B> : e.BF
    , <Intersection (e.AF) e.BF> : {
        True = True;
        False = <FindRRConflict t.Follow (e.A) e.VE>;
    };
    t.Follow (e.A) e.Else
    = False;
}

ReduceReduceState {
    t.Follow e.VB (e.A' ➡ 'e.aa'.') e.VE
    , <FindRRConflict t.Follow (e.A) e.VE> : {
        True = True;
        False = <ShiftReduceState t.Follow e.VE>;
    };
    t.Follow e.Else
    = False;
}

ReduceReduce {
    t.Automata t.Follow e.N
    , <List-Get t.Automata <Symb e.N>> : {
        /*empty*/ = False;
        e.V
        , <ReduceReduceState t.Follow e.V> : {
            True = True;
            False = <ReduceReduce t.Automata t.Follow <Add (e.N) 1>>;
        };
    };
    e.Else = ;
}

SLRCheck {
    t.Automata t.Follow
    , <ShiftReduce t.Automata t.Follow 1> : {
        True = False;
        False
        , <ReduceReduce t.Automata t.Follow 1> : {
            True = false;
            False = true;
        };
    };
}

ReadLines {
    s.Stream (e.Stop)
    , <Get s.Stream> : {
        e.Line 0 = e.Line;
        e.Stop = ;
        e.Line = e.Line'\n'<ReadLines s.Stream (e.Stop)>;
    }
}

Order {
    (e.Ni) e.Nj (e.N)
    , <List-Get <Cp 'Paths'> e.N> : {
        /*empty*/ = <Cp '>'>;
        e.LB1 (e.Ni) e.LB2 e.Nj e.LE = <Order (e.Ni) e.Nj (<Add (e.N) 1>)>;
        e.Reverse = <Cp '<'>;
    }
}

Sort {
  /* пусто */ = /* пусто */;

  t.Pivot e.Items
    = <Reduce
        {
          ((e.Less) (e.Equal) (e.Greater)) t.Next
            = <Order t.Next t.Pivot (0)>
            : {
                '<' = ((e.Less t.Next) (e.Equal) (e.Greater));
                '>' = ((e.Less) (e.Equal) (e.Greater t.Next));
              };
        }
        ( (/* less */) (t.Pivot /* equal */) (/* greater */) )
        e.Items
      >
    : ((e.Less) (e.Equal) (e.Greater))
    = <Sort e.Less> e.Equal <Sort e.Greater>;
}

Unicode {
    s.S1 s.S2 e.S3
    , <Map {
        s.A
        , <Compare (<Ord s.A>) 127> : {
            '+' = False;
            s.E = True;
        };
    } s.S1 s.S2 e.S3> : {
        True True True = False s.S1 s.S2 e.S3;
        e.Else = True s.S1 s.S2 e.S3;
    };
    s.A = False s.A;
*    s.A s.B = False s.A s.B;
}