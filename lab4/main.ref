*$FROM LibraryEx
$EXTERN Map, Reduce;
*$FROM List
$EXTERN List-Create, List-Insert, List-InitForEach,
List-Append, List-AppendList, List-Get, List-ToJSON, List-Keys, List-WhereIn;
$ENTRY GO {
    , <Open 'r' 1 <Arg 1>> :
    , <ReadLines 1 ('#priority')> : '#for\n'e.Type'\n'
    , e.Type : {
        'i'
        , <ParseAutomata 1> : t.Automata
        , <ParseFollow 1> : t.Follow
        , <Close 1> :
        , <Open 'w' 1 <Arg 2>> :
        = <Putout 1 <SLRCheck t.Automata t.Follow>><Close 1>;
        'p'
        , <ReadLines 1 ('#state')> : e.Priority'\n#arrow\n'e.Arrow'\n#line\n'e.Line'\n#counter\n'
            e.Counter'\n#string\n'e.String
        , e.Priority : {
            'true' = <Br '<=>'><Br '>=<'>;
            'false' = <Br '<=<'><Br '>=>'>;
        } :
        , <ParseSTerms 1> : t.Terms
*        , <Prout <List-ToJSON t.Terms>> :
        , <ParsePaths 1> : t.Paths
*        , <Prout <List-ToJSON t.Paths>> :
        , <ParseFollow 1> : t.Follow
        , <Br 'Paths='t.Paths> :
        , <Br 'OrdTerms='<Sort <List-Keys t.Terms>>> :
        , <PanicRead t.Follow (<Numb e.Arrow>) (<Numb e.Line>) (<Numb e.Counter>) e.String> :
        = ;
    };
}

PanicRead {
    t.Follow (e.Arrow) (e.Line) (e.Counter) /*empty*/
    = <Prout 'Is it possible?'><Exit 1>;
    t.Follow (e.Arrow) (e.Line) (e.Counter) '\n' e.String
    = <PanicRead t.Follow
        (e.Arrow) (<Add (e.Line) 1>)
        (<Sub (<Add (e.Counter) <Sub (e.Arrow) e.Counter>>) 1>) e.String>;
    t.Follow (e.Arrow) (e.Line) (e.Counter) s.C1 s.C2 e.String
    , <Unicode s.C1 s.C2> : {
        True e.W
        , e.String : {
            s.C3 e.String
            , <Unicode s.C1 s.C2 s.C3> : {
                True e.W = <PanicRead (U e.W) t.Follow (e.Arrow) (e.Line) (e.Counter) e.W e.String>;
                False e.W = <PanicRead (U s.C1 s.C2) t.Follow (e.Arrow) (e.Line) (e.Counter) e.W e.String>;
            };
            /*empty*/ =

        };
        False e.W = <PanicRead (NU s.C1) t.Follow (e.Arrow) (e.Line) (e.Counter) e.W e.String>;
    };

    t.Follow (e.Arrow) (e.Line) (e.Counter) s.C e.String
    , <IsFollow t.Follow s.C> : {
        (e.Len) e.T = <WriteResults (e.Arrow) (e.Line) (e.Counter) (e.T) e.Len>;
        /*empty*/ = <PanicRead t.Follow (<Add (e.Arrow) 1>) (e.Line) (e.Counter) e.String>;
    };

    (U e.W) t.Follow (e.Arrow) (e.Line) (e.Counter) e.W e.String
    , <IsFollow t.Follow e.W> : {
        (e.Len) e.T = <WriteResults (e.Arrow) (e.Line) (e.Counter) (e.T) e.Len>;
        /*empty*/ = <PanicRead t.Follow (<Add (e.Arrow) 1>) (e.Line) (e.Counter) e.String>;
    };

    (NU s.C) t.Follow (e.Arrow) (e.Line) (e.Counter) s.C e.String
    , <IsFollow t.Follow s.C> : {
        (e.Len) e.T = <WriteResults (e.Arrow) (e.Line) (e.Counter) (e.T) e.Len>;
        /*empty*/ = <PanicRead t.Follow (<Add (e.Arrow) 1>) (e.Line) (e.Counter) e.String>;
    };
    e.Else = <Prout e.Else> <Exit 0 >;

}

WriteResults {
    (e.Arrow) (e.Line) (e.Counter) (e.T) e.Len
    , <Open 'w' 2 <Arg 2>> :
    = <Putout '#arrow\n'<Symb e.Arrow>'\n#line\n'<Symb e.Line>'\n#counter\n'<Symb e.Counter>
        '\n#nterm\n'<Symb e.T>'\n#drop\n'<Symb e.Len>><Close 2>;
}

OlderTerm {
    e.TB e.T e.TE
    , <Cp 'OrdTerms'> : e.T e.OTE
    = e.T;
}

OlderRule {
    (e.Max) (e.T1' ➡ 'e.a'.'e.b) e.Rules
    , <Lenw e.a> : s.L e.a
    , <Compare (e.Max) s.L> : {
        '+' = <OlderRule (e.Max) e.Rules>;
        e.le = <OlderRule (s.L) e.Rules>;
    };
}

IsFollow {
    t.Follow e.C
    , <List-WhereIn t.Follow e.C> : {
        /*empty*/
*        , <Prout NOTHING (s.C) IN t.Follow> :
        = ;
        e.Terms
        , <Print FOUND e.C IN e.Terms> :
        , <OlderTerm e.Terms> : e.Term
        , <List-Get t.Follow e.Term> : e.Rules
        = <OlderRule (0) e.Rules>;
    }
}

ParseSTerms {
    s.Stream
    , <List-Create> : t.States
    = <ParseSTerms_ s.Stream t.States>;
}

ParseSTerms_ {
    s.Stream t.States
    , <Get s.Stream> : {
        e.Term' ➡ 'e.Rule = <ParseSTerms_ s.Stream <List-Append t.States (e.Term) e.Rule>>;
        '#paths' = t.States;
    }
}

ParsePaths_ {
    s.Stream t.Paths (e.N)
    , <Get s.Stream> : {
        '#begin' = <ParsePaths_ s.Stream t.Paths (e.N)>;
        '#end' = <ParsePaths_ s.Stream t.Paths (<Add (e.N) 1>)>;
        '#follow' = t.Paths;
        e.Term = <ParsePaths_ s.Stream <List-Append t.Paths (e.N) e.Term> (e.N)>;
    };
}

ParsePaths {
    s.Stream
    , <List-Create> : t.Paths
    = <ParsePaths_ s.Stream t.Paths (0)>;
}

ParseState {
    (e.N) s.Stream t.List
    , <Get s.Stream> : {
        '#end' = t.List;
        e.Rule = <ParseState (e.N) s.Stream <List-Append t.List (e.N) e.Rule>>;
    };
}

ParseAutomata_ {
    s.Stream t.List
    , <Get s.Stream> :  {
        '#State = 'e.N
        , <Get s.Stream> : e.Begin
        = <ParseAutomata_ s.Stream <ParseState (e.N) s.Stream t.List>>;
        '#follow' = t.List;
    };
}

ParseAutomata {
    s.Stream
    , <List-Create> : t.List
    = <ParseAutomata_ s.Stream t.List>;
}

ParseFTerm {
    s.Stream t.List (e.T)
    , <Get s.Stream> : {
        '#end' = t.List;
        e.F = <ParseFTerm s.Stream <List-Append t.List (e.T) e.F> (e.T)>;
    };
}

ParseFollow_ {
    s.Stream t.List
    , <Get s.Stream> : {
        '#Nterm = 'e.T
        , <Get s.Stream> : e.Begin
        , <ParseFTerm s.Stream t.List (e.T)> : t.List^
        = <ParseFollow_ s.Stream t.List>;
        0 = t.List;
        e.Else = <Prout e.Else><Exit 0>;
    };
}

ParseFollow {
    s.Stream
    , <List-Create> : t.List
    = <ParseFollow_ s.Stream t.List>;
}

IsIn {
    (e.LB (e.X) e.LE) e.X = True;
    e.Else = False
}

FindSRConflict {
    t.Follow (s.a) (s.X) e.VB (e.T1' ➡ 'e.a s.a'.') e.VE
*    , <Prout MAYBE FOR (s.a) (X s.X)> :
    , <List-Get t.Follow e.T1> : e.F
*    , <Prout FOLLOW FOR (e.T1) IS e.F> :
    , <IsIn (e.F) s.X> : {
        True = True;
        False = <FindSRConflict t.Follow (s.a) (s.X) e.VE>;
    };
    t.Automata (s.a) (s.X) e.V
    = False;
*    = <Prout NOT FOUND FOR (s.a) (s.X) IN e.V>False;
}

ShiftReduceState {
    t.Follow e.VB (e.T1' ➡ 'e.a s.a'.'s.X e.b) e.VE
*    , <Prout (e.T1' ➡ 'e.a s.a'.'s.X e.b) (s.X) (e.b)> :
    , <IsNTerm s.X> : {
        True = <ShiftReduceState t.Follow e.VE>;
        False
*        , <Prout RUN FOR s.X> :
        , <FindSRConflict t.Follow (s.a) (s.X) e.VB e.VE> : {
            True = True;
            False = <ShiftReduceState t.Follow e.VE>;
        };
    };
    t.Follow e.Else
    = False;
*    = <Prout NOT FOUND (e.Else)>False;
}

ShiftReduce {
    t.Automata t.Follow e.N
    , <List-Get t.Automata <Symb e.N>> : {
        /*empty*/ = False;
        e.V
*        , <Prout (e.N) (e.V)> :
        , <ShiftReduceState t.Follow e.V> : {
            True = True;
            False = <ShiftReduce t.Automata t.Follow <Add (e.N) 1>>;
        };
    };
}

IsNTerm {
    s.A
    , <Compare (<Ord s.A>) <Ord 'Z'>> : {
        '-'
        , <Compare (<Ord s.A>) <Ord 'A'>> : {
            '-' = False;
            s.E = True;
        };
        s.E = False;
    };
    e.T = True; /*eps?*/
}

Intersection {
    (e.TB(e.T)e.TE) e.TBB e.T e.TEE
    = True;
    (e.T1) e.T2
    = False;
}

FindRRConflict {
    t.Follow (e.A) e.VB (e.B' ➡ 'e.bb'.') e.VE
    , <List-Get t.Follow e.A> : e.AF
    , <List-Get t.Follow e.B> : e.BF
    , <Intersection (e.AF) e.BF> : {
        True = True;
        False = <FindRRConflict t.Follow (e.A) e.VE>;
    };
    t.Follow (e.A) e.Else
    = False;
}

ReduceReduceState {
    t.Follow e.VB (e.A' ➡ 'e.aa'.') e.VE
    , <FindRRConflict t.Follow (e.A) e.VE> : {
        True = True;
        False = <ShiftReduceState t.Follow e.VE>;
    };
    t.Follow e.Else
    = False;
}

ReduceReduce {
    t.Automata t.Follow e.N
    , <List-Get t.Automata <Symb e.N>> : {
        /*empty*/ = False;
        e.V
        , <ReduceReduceState t.Follow e.V> : {
            True = True;
            False = <ReduceReduce t.Automata t.Follow <Add (e.N) 1>>;
        };
    };
    e.Else = ;
}

SLRCheck {
    t.Automata t.Follow
    , <ShiftReduce t.Automata t.Follow 1> : {
        True = False;
        False
        , <ReduceReduce t.Automata t.Follow 1> : {
            True = false;
            False = true;
        };
    };
}

ReadLines {
    s.Stream (e.Stop)
    , <Get s.Stream> : {
        e.Line 0 = e.Line;
        e.Stop = ;
        e.Line = e.Line'\n'<ReadLines s.Stream (e.Stop)>;
    }
}

Order {
    (e.Ni) e.Nj (e.N)
    , <List-Get <Cp 'Paths'> e.N> : {
        /*empty*/ = <Cp '>'>;
        e.LB1 (e.Ni) e.LB2 e.Nj e.LE = <Prout e.LB1 (e.Ni) e.LB2 (e.Nj) e.LE><Order (e.Ni) e.Nj (<Add (e.N) 1>)>;
        e.Reverse = <Cp '<'>;
    }
}

Sort {
  /* пусто */ = /* пусто */;

  t.Pivot e.Items
    = <Reduce
        {
          ((e.Less) (e.Equal) (e.Greater)) t.Next
            = <Order t.Next t.Pivot (0)>
            : {
                '<' = ((e.Less t.Next) (e.Equal) (e.Greater));
                '>' = ((e.Less) (e.Equal) (e.Greater t.Next));
              };
        }
        ( (/* less */) (t.Pivot /* equal */) (/* greater */) )
        e.Items
      >
    : ((e.Less) (e.Equal) (e.Greater))
    = <Sort e.Less> e.Equal <Sort e.Greater>;
}

Unicode {
    s.S1 s.S2 e.S3
    , <Map {
        s.A
        , <Compare (<Ord s.A>) 127> : {
            '+' = False;
            s.E = True;
        };
    } s.S1 s.S2 e.S3> : {
        True True True = False s.S1 s.S2 e.S3;
        e.Else = True s.S1 s.S2 e.S3;
    };
    s.A = False s.A;
*    s.A s.B = False s.A s.B;
}