$ENTRY NOracle-Get {
    e.Path = <Br 'Path='e.Path>;
}

$ENTRY NOracle-MEMBER {
    e.w
    , <System 'julia '<Cp 'Path'>' 'e.w' > mem.txt'> : e.Status
    , <Open 'r' 2 'mem.txt'> :
    , <Get 2> : {
        'true' = 1;
        'false' = 0;
    };
}

$ENTRY NOracle-EQUIVALENCE {
    (e.P) e.MaxL
*    , <Prout e.P (e.MaxL) <Type e.P> (<Type e.MaxL>)> :
    , <System 'julia generator.jl 'e.P' '<Symb e.MaxL>' > equiv.txt'> : e.Status
    , <Open 'r' 2 './equiv.txt'> :
    , <CollectTests 2 () ()> : (e.Ins)e.NotIns
    , <Prout InL (e.Ins)'\n'NotInL (e.NotIns)> :
    , <Close 2> :
    , <FindCounter (1) e.Ins> : {
        True
        , <FindCounter (0) e.NotIns> : {
            True = True;
            False e.Counter (s.Actual) = False e.Counter (s.Actual);
*            False <FindMinCounter (s.Actual) (e.Counter)> (s.Actual);
        };
        False e.Counter (s.Actual) = False e.Counter (s.Actual);
*         False <FindMinCounter (s.Actual) (e.Counter)> (s.Actual);
    };
}

FindCounter {
    (s.Want) /*empty*/
    = True;
    (s.Want) (e.w) e.w-e
    , <NOracle-MEMBER e.w> : {
        s.Want = <FindCounter (s.Want) e.w-e>;
        s.Else = False e.w (s.Else);
*         <Prout expected s.Want 'but got 's.Else' for 'e.w>
    };
}

CollectTests {
    s.Stream (e.Ins) (e.NotIns)
    , <Get s.Stream> : {
        0 = (e.Ins) e.NotIns;
        'in=false' = <CollectTests s.Stream (e.Ins) (e.NotIns)>;
        'notin=false' = <CollectTests s.Stream (e.Ins) (e.NotIns)>;
        'in='e.W
        , e.Ins : {
            e.I-B (e.W) e.I-E = <CollectTests s.Stream (e.Ins) (e.NotIns)>;
            e.I = <CollectTests s.Stream (e.Ins (e.W)) (e.NotIns)>;
        };

        'notin='e.W
        , e.NotIns : {
            e.NI-B (e.W) e.NI-E = <CollectTests s.Stream (e.Ins) (e.NotIns)>;
            e.NI = <CollectTests s.Stream (e.Ins) (e.NotIns (e.W))>;
        };
    };
}